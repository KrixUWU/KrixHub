local AimlockModule = {}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

-- Player
local player = Players.LocalPlayer

-- Wait for Character
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local camera = workspace:WaitForChild("CurrentCamera")
local playerGui = player:WaitForChild("PlayerGui")

-- State
local AimlockPlayerEnabled, AimlockNpcEnabled = false, false
local cachedEnemy, cachedBoss = nil, nil
local currentTarget = nil
local currentHighlight = nil
local renderConn = nil

local MiniPlayerCreated, MiniNpcCreated = false, false
local MiniPlayerState, MiniNpcState = nil, nil
local MiniPlayerGui, MiniNpcGui = nil, nil

-- =========================
-- Helpers
-- =========================
local function safeDisconnect(conn)
    if conn then pcall(function() conn:Disconnect() end) end
end

local function isEnemy(targetPlayer)
    if not targetPlayer or targetPlayer == player then return false end
    local myTeam = player.Team
    local targetTeam = targetPlayer.Team
    if not myTeam or not targetTeam then return false end
    if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then return true end
    if myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then return true end
    return false
end

local function getNearestEnemy(maxDistance)
    local nearest, shortest = nil, maxDistance or 100
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and isEnemy(p) and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local dist = (p.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
            if dist < shortest then
                shortest = dist
                nearest = p.Character.HumanoidRootPart
            end
        end
    end
    return nearest
end

local function getNearestBoss(maxDistance)
    local nearest, shortest = nil, maxDistance or 500
    local bossFolder = Workspace:FindFirstChild("Enemies")
    if bossFolder then
        for _, boss in pairs(bossFolder:GetChildren()) do
            local humanoid = boss:FindFirstChildOfClass("Humanoid")
            if boss:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
                local dist = (boss.HumanoidRootPart.Position - hrp.Position).Magnitude
                if dist < shortest then
                    shortest = dist
                    nearest = boss.HumanoidRootPart
                end
            end
        end
    end
    return nearest
end

-- =========================
-- Mini Toggle
-- =========================
local function createMiniToggle(name, position, stateVarRef, realVarSetter)
    if playerGui:FindFirstChild(name .. "MiniToggleGui") then
        playerGui[name .. "MiniToggleGui"]:Destroy()
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = name .. "MiniToggleGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 70, 0, 40)
    button.Position = position
    button.TextScaled = true
    button.TextWrapped = false
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BorderSizePixel = 0
    button.Parent = screenGui

    local uicorner = Instance.new("UICorner")
    uicorner.CornerRadius = UDim.new(0, 8)
    uicorner.Parent = button

    local function updateUI(state)
        button.Text = name .. (state and " ON" or " OFF")
        button.BackgroundColor3 = state and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(200, 50, 50)
    end

    button.MouseButton1Click:Connect(function()
        stateVarRef.value = not stateVarRef.value
        realVarSetter(stateVarRef.value)
        updateUI(stateVarRef.value)
    end)

    -- Drag
    local dragging = false
    local dragStart, startPos
    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = button.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            button.Position = UDim2.new(
                0,
                math.clamp(startPos.X.Offset + delta.X, 0, camera.ViewportSize.X - button.AbsoluteSize.X),
                0,
                math.clamp(startPos.Y.Offset + delta.Y, 0, camera.ViewportSize.Y - button.AbsoluteSize.Y)
            )
        end
    end)

    updateUI(stateVarRef.value)
    return screenGui
end

-- =========================
-- Aimlock
-- =========================
local function setAimlockTarget(targetModel)
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
    currentTarget = targetModel
end

local function startRenderLoop()
    if renderConn then return end
    renderConn = RunService.RenderStepped:Connect(function()
        if not AimlockPlayerEnabled and not AimlockNpcEnabled then
            safeDisconnect(renderConn)
            renderConn = nil
            return
        end

        if AimlockPlayerEnabled then
            cachedEnemy = getNearestEnemy(500)
            if cachedEnemy then setAimlockTarget(cachedEnemy.Parent) end
        end

        if AimlockNpcEnabled then
            cachedBoss = getNearestBoss(500)
            if cachedBoss then setAimlockTarget(cachedBoss.Parent) end
        end
    end)
end

-- =========================
-- API
-- =========================
function AimlockModule:SetMiniTogglePlayerAimlock(state)
    AimlockPlayerEnabled = state
    if not MiniPlayerCreated then
        MiniPlayerState = { value = state }
        MiniPlayerGui = createMiniToggle("Player", UDim2.new(0, 10, 0, 90), MiniPlayerState, function(val)
            AimlockPlayerEnabled = val
            startRenderLoop()
        end)
        MiniPlayerCreated = true
    else
        MiniPlayerState.value = state
        MiniPlayerGui.Enabled = state
    end
    startRenderLoop()
end

function AimlockModule:SetMiniToggleNpcAimlock(state)
    AimlockNpcEnabled = state
    if not MiniNpcCreated then
        MiniNpcState = { value = state }
        MiniNpcGui = createMiniToggle("NPC", UDim2.new(0, 10, 0, 50), MiniNpcState, function(val)
            AimlockNpcEnabled = val
            startRenderLoop()
        end)
        MiniNpcCreated = true
    else
        MiniNpcState.value = state
        MiniNpcGui.Enabled = state
    end
    startRenderLoop()
end

return AimlockModule
